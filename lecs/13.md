# Данные в конкурентной среде

Работа с данными в конкурентной и, возможно, распределенной среде создает дополнительную проблему синхронизации их изменения. При отсуствии синхронизации могут проявится проблемы потери части изменений, нарушения целостности данных, вплоть до сбоя в работе програм из-за нарушений инвариантов, на которые расчитаны те или иные алгоритмы обращения к данным.


## Транзакции

Транзакции — это операции над данными, которые обладают 3 (или 4) свойствами, выраженными аббревиатурой ACI(D): атомарность, целостность, изоляция и сохранность (последнее актуально только в случае систем БД). Такие операции гарантируют сохранность и корректную модификацию данных.

Транзакции бывают:

- пессимистическими: полное блокирование данных на все время операции
- оптимистическими: создание копии данных, выполнение операций над копией и блокирование оригинала только на время обновления, которое может не состоятся, если параллельно с выполнением транзакции данные были изменены кем-то другим — в этом случае требуется откат и повторное выполнение транзакции


## Неблокируемые структуры данных

Это такие структуры данных, которые можно модифицировать, не прибегая к транзакциям. Примеры таких структур:

- атомарный счетчик
- неблокируемая очередь

Реализация таких структур, как правило, выполняется с использованием аппаратных примитивов синхронизации, таких как CAS или LL/SC.


## Персистентные/функциональные типы данных

Это структура данных и набор операций над ней, который гарантирует сохранность предыдущей версии при выполнении операций модификации. Примитивный вариант такого типа данных — это структура, для каждой модификации которой создается новая копия. Очевидно, что такой вариант является неэффективным как с точки зрения времени выполнения, так и используемых ресурсов памяти. Интересны эффективные функциональные струтктуры данных, причем доказано, что накладные расходы на то, что сделать персистентной любую структуру — требуют максимум `O(log n)`.  

Примеры персистентных структур данных:

- связный список, который используется как стек (операции модфиикации: только push и pop) — накладные расходы: `O(1)`
- очередь на основе двух стеков
- массив на основе дерева — накладные расходы: `O(log_a n)` (где, на практике, `a` имеет порядок 32 и больше)


## Распределенный консенсус

В распределнной среде действует CAP-теорема, которая указывает на то, что если мы хотим всегда иметь данные, которые находятся в распределенной системе, в целостном состоянии, то должны пожертвовать постоянной доступностью системы их хранения. Как правило, это является недопустимым, поэтому жертвовать приходится целостностью (согласованностью, consistency). Однако, хотя добится постоянной целостности в этой сценарии не представляется возможным, можно поставить более мягкое, но выполнимое условие: конечной согласованности (eventual consistency), которое гарантирует, что в те периоды, когда в системе нет проблем разделения (partition, т.е. не возможности связи каких-то узлов между собой), она со временем приходит в полностью согласованное состояние. Условие строгой конечной согласованности требует, чтобы этот переход происходил сразу же после того, как в системе проходят проблемы разделения.

Для установления распределенного консенсуса, который гарантирует конечную согласованность, придумано много алгоритмов. Самые известные среди них:

- 2-х и 3-х фазный комит
- PAXOS
- RAFT


## CRDT

Помимо алгоритмов распределенного консенсуса, также существуют типы данных, которые поддерживают распределенную репликацию с условием сильной конечной согласованности. Такие структуры называются неконфликтными реплицируемыми (conflict-free replicated data types).

Условием, которое налагается на такую структуру есть то, что все операции ее модификации должны обладать свойствами: комутативности и ассоциативности (независимости результата от порядка), а также идемпотентности (независимости результата от количества повторений одной и той же операции).

CDRT бывают двух видов: 

- CmRDT (commutative replicated data types) — осуществляющие репликацию за счет передачи операций модификации (требуют гарантий идемпотентности на уровне коммуникационной среды)
- CvRDT (convergent replicated data types) — осуществляющие репликацию за счет слияния всех состояний (требуют больших накладных расходов)

Примеры:

- Конвергентный только увеличивающий счетчик (G-counter), а также счетчик с возможностью как увеличения, так и уменьшения (PN-counter)
- Конвергентное множество только с возможностью добавления (G-set), а также с возможностью удаления, но без возможности повторного добавления (2P-set)
- для последовательностей: LSEQ, DocTree, Woot


## Литература

- https://www.research.ibm.com/people/m/michael/podc-1996.pdf
- https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
- http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence/
- https://infoscience.epfl.ch/record/64410/files/techlists.pdf
- http://stackoverflow.com/questions/4399837/what-is-the-benefit-of-purely-functional-data-structure
- http://cs.stackexchange.com/questions/18262/what-classes-of-data-structures-can-be-made-persistent
- https://habrahabr.ru/post/272987/
- https://speakerdeck.com/ajantis/practical-demystification-of-crdts
- https://medium.com/@istanbul_techie/a-look-at-conflict-free-replicated-data-types-crdt-221a5f629e7e#.pkw8nuk5u
- https://github.com/pfrazee/crdt_notes
- http://thesecretlivesofdata.com/raft/
- http://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdf
