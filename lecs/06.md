# Минимальное остовное дерево (MST)

**Минимальное остовное дерево** взвешенного ненаправленного графа — это дерево (или лес деревьев для графа с несколькими компонентами свзности), которое включает все вершины графа и имеет минмиальную длину.

Эта задача интересна тем, что она может эффективно решаться с помощью жадных алгоритмов.

## Алгоритм Прима

Алгоритм Прима случайным образом берет стартовую вершину и на каждом шаге выбирает кратчайшее ребро, которое связывает вершины, уже добавленные в дерево с вершинами, которые доступны из них. Таким образом, на каждом шаге алгоритма рассмтаривается 3 множеста: добавленных вершин, доступных (пограничных) вершин и пока недоступных вершин. Ключ к эффективной реализации алгоритма — эффективный выбор кратчайшего ребра, соединяющего доступные и пограничные вершины. Наиболее удачный вариант — это куча Фибоначчи, содержащая все непросмотренные вершины и расстояния до них из просмотренных вершин, которые обновляются при добавлении каждой новой варшины.

Сложность алгоритма (`V` — количество вершин, `E` — количество ребер):

- при использовании просто списка ребер: `O(V^2)`
- при использовании кучи Фибоначчи: `O(E * logV)`


## Алгоритм Краскала

Алгоритм Краскала выбирает по очереди наименьшие ребра и добавляет их в список ребер будущего дерева, если они не образуют цикла. Ключ к эффективной реализации — проверка на образование цикла. Это может быть сделано с помощью структуры для хранения непересекающихся множеств (как правило, Union-Find).

Структура Union-Find поддерживает 2 операции:

- `Find(A)` возвращает идентификатор множества, к которому принадлежит элемент A
- `Union(A, B)` объединяет множества, к которым относится `A` и `B`. Т.е., если до Union `Find(A) = X`, а `Find(A) = Y`, то после — обе операции должны возвращать либо `X`, либо `Y`


## Литература

- http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture13.pdf
- http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/
- http://algs4.cs.princeton.edu/15uf/
