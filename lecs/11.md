# Хеш-таблицы

## Применение структур типа ключ-значение

- основная структура данных во многих динамических языках (т.н. объект), таких как JS и Lua
- key-value store
- представление любых словарей (например, в лингвистике)
- эффективная реализация множеств
- мемоизация


## Варианты реализации структуры типа ключ-значение

- список/массив пар (ассоциативный массив)
- хеш-таблица
- поисковое дерево


## Хеш-таблица

Хеш-таблицы — это основанные на массивах структуры данных, которые имеют амортизированную сложность основных (вставка, модификация, удаление) операций — O(1). Однако это происходит за счет следующих особенностей:

- данные в хеш-таблице не могут быть упорядоченны произвольным образом
- хотя время доступа к элементам и является константой, но сама константа может быть достаточно большой
- в хеш-таблицах, как правило, происходит не полностью эффективное использование памяти (потери могут составлять от 30 до 50%)
- таблицы не поддерживают эффективно такие операции как поиск наибольшего элемента (хотя есть варианты, такие как Linked Hash Table)

Хеш-таблица получается из массива добавлением операции хеширования ключа, в результате которой можно узнать элемент массива, где должна находится пара ключ-значение. При этом разные ключи могут давать одинаковый хеш код, что приводит к коллизиям (невозможности запистаь или найти элемент в точности в указанной хеш-функццией ячейке). 

Варианты реализации хеш-таблиц с учетом борьбы с коллизиями:

- цепная — если в какую-то ячейку долен быть записан более, чем 1 элемент, то эти элементы размещаются в дополнительной структуре, которая может быть:
  - связным списком/динамическим массивом
  - деревом
  - еще одной хеш-таблицей (возможно, с другой хеш-функцией)
- открытая адресация — если ячейка занята, то мы смотрим на соседей и ищем среди них пустую ячейку или же нужный нам ключ и так по рекурсии. Варианты реализации:
  - линейная/квадратичная
  - двойное хеширование
  - гибрид линейной модели и двойного хеширования
  - кукушечная
  - hopscotch
  - 2-х вариантный

Цепная реализация хеш-таблиц позволяет хранить в таблице неограниченный объем данных, но в этом случае таблица вырождается в множество списков или деревьев.

Хеш-таблицы с открытой адресацией более простые и эффективные, но могут хранить не больше значений, чем размер массива. При этом при превышении заполненности массива 0.7-0.8 у них существенно падает производительность. Для борьбы с такой ситуацией используется динамическое расширение (для этого также есть разные стратегии).


## Хеш-функции

[Парадокс дней рождения](http://betterexplained.com/articles/understanding-the-birthday-paradox/)

Задачи (некриптографической) хеш-функции:

- сократить диапазон ключей до размера массива хеш-таблицы
- перераспределить ключи примерно равномерно
- при этом хеши соседних ключей должны, в идеале, оказаться далеко друг от друга

Простейший вариант хеш-функции: битовая маска, которая берет только несколько бит из численного представления данных.

Большинство хеш-функций используют последовательное преобразование данных путем сложения, усножения и операции `xor` с последующим делением по модулю, чтобы результат оказался в требуемом интервале.

Хеш-функции, как правило, являются необратимыми.


## Идеальное хеширование

Идеальное хеширование — это подбор для заранее известного набора ключей такой хеш-функции, которая гарантирует отсутствие коллизий (т.е. время доступа к ключу ровно за k операций, где k — небольшое число: 1,2). Поиск такой хеш-функции, как правило, выполняется с помощью рандомизированного алгоритма, время работы которого зависит от размера результирующей таблицы:

- обычное идаельное хеширование создает таблицу с некоторым запасом (20-30%)
- минимальное идеальное хеширование создает таблицу, размер которой равен числу ключей
- также может использоваться многоуровневая таблица (как в цепном методе), где для каждой коллизии подбирается своя идеальная таблица.


## Консистентное хеширование

Консистентное хеширование — это способ построения хеш-функций для распределенных хеш-таблиц, который решает задачу минимазации перераспределения ключей при добавлении или удалении нового узла. В распределенной хеш-таблице из k узлов, на каждом узле будет хранится в среднем `1/k` ключей. При использовании обычных хеш-функций в случае удаления или добавления нового узла все ключи нужно будет перераспределить между узлами. Однако, в идеале это число можно сократить до порядка `1/k`. Эту задачу и решается в рамках консистентного хеширования. 


## To read

- http://stackoverflow.com/questions/10256974/under-the-hood-are-javascript-objects-hash-tables
- http://stackoverflow.com/questions/2624192/good-hash-function-for-strings
- http://computinglife.wordpress.com/2008/11/20/why-do-hash-functions-use-prime-numbers/
- http://isthe.com/chongo/tech/comp/fnv/
- http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html
- http://stackoverflow.com/questions/21126507/why-does-sxhash-return-a-constant-for-all-structs
- http://www.tom-e-white.com/2007/11/consistent-hashing.html
- http://michaelnielsen.org/blog/consistent-hashing/
- https://www.quora.com/How-does-rendezvous-hashing-compare-with-consistent-hashing-When-should-one-be-chosen-over-the-other
- http://www.cs.wustl.edu/~schmidt/PDF/gperf.pdf
- http://burtleburtle.net/bob/hash/perfect.html
- http://homepages.dcc.ufmg.br/~nivio/papers/cikm07.pdf
